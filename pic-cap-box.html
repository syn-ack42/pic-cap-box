<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../paper-icon-button/paper-icon-button.html">
<!--
`pic-cap-box`
A user input element to select multiple pictures (or photos on a mobile device) which also displayes previews.
The pictures selected by the user are returned as an array in a bound attribute.
Pictures can be rescaled to reduce image size.

@demo demo/index.html
-->

<dom-module id="pic-cap-box">
  <template>
    <style>
      :host {
        display: block;
        width: inherit;
        height: inherit;
        overflow-y: scroll;
      }
      .photo_review_tile {
        position: relative;
        display: inline-block;

        width: var(--photo-review-tile-size, 80px);
        height: var(--photo-review-tile-size, 80px);

        margin: 3px;
        border-style: dashed;
        border-width: thin;
      }

      .perview_img {
        width: inherit;
        height: inherit;
        position: absolute;
      }
      .clear_button {
        width: 40px;
        height: 40px;
        position: absolute;
        top: 55%;
        left: 55%;
        background-color: white;
        opacity: 0.8;
      }
      .upload-size-box {
        font-size: x-small;
        font-style: italic;
        text-align: right;
        padding-right: 10px;
      }
    </style>
      <template id='pictureTiles' is="dom-repeat" items="[[pictureData]]" indexAs="{{index}}">
          <div class='photo_review_tile' on-tap="_showFileDialog" picindex="{{index}}" >
            <img src="[[_getImageData(pictureData.*, index)]]" alt="" id="show-picture_{{index}}" class="perview_img" />
            <paper-icon-button hidden&="{{!pictureData.index}}" id="delete-picture_{{index}}" class="clear_button" icon="delete" title="delete" on-tap="_clearImageTapped" picindex="{{index}}"></paper-icon-button>
          </div>
          <input type="file" id="take-picture_{{index}}" accept="image/*" picindex="{{index}}" on-change='_pictureSelected' hidden='hidden' >
      </template>
      <template id='addNewPictureTile' is="dom-if" if="{{!_maxPicReached(pictureData.*)}}" >
          <div class='photo_review_tile' on-tap="_showFileDialog" >
            <img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMDAlIiBoZWlnaHQ9IjEwMCUiIHZpZXdCb3g9IjAgMCA0OCA0OCI+CiAgICA8cGF0aCBkPSJNMCAwaDQ4djQ4aC00OHoiIGZpbGw9Im5vbmUiIC8+CiAgICA8cGF0aCBmaWxsPSIjNjE2MTYxIiBkPSJNMjYgMTRoLTR2OGgtOHY0aDh2OGg0di04aDh2LTRoLTh2LTh6bS0yLTEwYy0xMS4wNSAwLTIwIDguOTUtMjAgMjBzOC45NSAyMCAyMCAyMCAyMC04Ljk1IDIwLTIwLTguOTUtMjAtMjAtMjB6bTAgMzZjLTguODIgMC0xNi03LjE4LTE2LTE2czcuMTgtMTYgMTYtMTYgMTYgNy4xOCAxNiAxNi03LjE4IDE2LTE2IDE2eiIvPgo8L3N2Zz4K"
                alt="" id="add-picture" class="perview_img" />
          </div>
          <input type="file" id="take-picture" accept="image/*" on-change='_pictureSelected' hidden='hidden' >
      </template>
      <div class="upload-size-box">[[_dataSize]]</div>
  </template>

  <script>
    Polymer({

      is: 'pic-cap-box',

      properties: {
        /*Set the number of pictures the user may select*/
        'maxNumberOfPictures': {
            type: Number,
            value: 1,
          },
        /*Bind this attribute to an array to receive the pictures as base64 encoded jpeg data URLs*/
        'pictureData': {
          type: Array,
          value: [],
          notify: true,
          readOnly: false
        },
        /*Images will be rescaled to this pixel value on their long edge.*/
        'longEdgePixels': {
            type: Number,
        },
        /*Images will be rescaled to this pixel value on their short edge.*/
        'shortEdgePixels': {
          type: Number,
        },
        /*if an image is larger than this value it will be rescaled while keeping its proportions. Defaults to  1.5*/
        'maxMegaPixels': {
          type: Number,
          value: 1.5,
        },
      },
      observers: [
        '_maxNumPicChanged(maxNumberOfPictures)',
        '_pictureDataChanged(pictureData.*)'
      ],
      /*set pictureData. Muste be an array of base64 url encoded images*/
      setPictures: function(pictures) {
        if (pictures instanceof Array) {
          this.set('pictureData',[]);
          for (var i=0;i<pictures.length;i++) {
            this.push('pictureData', pictures[i]);
          }
        }
      },
      /*reset the  pictureData array */
      _maxNumPicChanged: function() {
        this.set('pictureData',[]);
      },
      _maxPicReached: function() {
        if (this.pictureData instanceof Array) {
          return (this.pictureData.length >= this.maxNumberOfPictures);
        }
        else {
          return false;
        }
      },
      _pictureDataChanged: function() {
        this._calcPictureDataSize();
      },
      _calcPictureDataSize: function() {
        var sumBytes = 0;
        for (var i=0; i<this.pictureData.length; i++) {
          if (this.pictureData[i]) {
            sumBytes += this.pictureData[i].length;
          }
        }
        if (this.pictureData.length > 0) {
          this._dataSize = Math.round(sumBytes/10000)/100 + " MB";
        }
        else {
          this._dataSize = "";
        }
      },
      _pictureSelected: function(event) {
        // Get a reference to the taken picture or chosen file
        var files = event.target.files, file;

        if (files && files.length > 0) {
          file = files[0];
          // Only process image files.
          if (!file.type.match('image.*')) {
            return;
          }
          var picIndex = event.currentTarget.picindex;
          if ((picIndex == null) || (picIndex == undefined)) {
            picIndex = this.pictureData.length;
          }
          else {
            picIndex = event.currentTarget.picindex*1;
          }
          var reader = new FileReader();
          var self = this;

          // Capture the file information.
          reader.onload = function(e) {
            //rescaling, and updating the data in the "_pictures" array (and tereby rendering the thumbnail)
            self._resizeAndStoreImage(e.target.result, picIndex);
          };

          // Read in the image file as a data URL.
          reader.readAsDataURL(file);
        }
      },
      _showFileDialog: function(event) {
        var picIndex = event.currentTarget.picindex;
        if ((picIndex == null) || (picIndex == undefined)) {
          document.querySelector("#take-picture").value = '';
          document.querySelector("#take-picture").click();
        }
        else {
          document.querySelector("#take-picture_"+picIndex).value = '';
          document.querySelector("#take-picture_"+picIndex).click();
        }
      },
      _clearImageTapped: function(event) {
        var picIndex = event.currentTarget.picindex*1;
        this.splice('pictureData', picIndex,1);
        event.stopPropagation();
      },
      //return the action image from the _pictures array or a svg image of a "+" in a circle
      //("change" is just the binding for the _pictures array to allow observing by polymer)
      _getImageData: function(change, index) {
        return this.pictureData[index]?this.pictureData[index]:'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMDAlIiBoZWlnaHQ9IjEwMCUiIHZpZXdCb3g9IjAgMCA0OCA0OCI+CiAgICA8cGF0aCBkPSJNMCAwaDQ4djQ4aC00OHoiIGZpbGw9Im5vbmUiIC8+CiAgICA8cGF0aCBmaWxsPSIjNjE2MTYxIiBkPSJNMjYgMTRoLTR2OGgtOHY0aDh2OGg0di04aDh2LTRoLTh2LTh6bS0yLTEwYy0xMS4wNSAwLTIwIDguOTUtMjAgMjBzOC45NSAyMCAyMCAyMCAyMC04Ljk1IDIwLTIwLTguOTUtMjAtMjAtMjB6bTAgMzZjLTguODIgMC0xNi03LjE4LTE2LTE2czcuMTgtMTYgMTYtMTYgMTYgNy4xOCAxNiAxNi03LjE4IDE2LTE2IDE2eiIvPgo8L3N2Zz4K';
      },
      //resize the picture and store it in the _pictures array
      _resizeAndStoreImage: function(imageData, wantedImageIndex) {
          // We create an image to receive the Data URI
          var img = document.createElement('img');
          var self = this;

          // When the event "onload" is triggered we can resize the image.
          img.onload = function() {
              // We create a canvas and get its context.
              var canvas = document.createElement('canvas');
              var context = canvas.getContext('2d');

              var scaledSizes = self._calculateRescaledPictureSize(this);
              canvas.width = scaledSizes.width;
              canvas.height = scaledSizes.height;
              context.scale(scaledSizes.width/this.width,scaledSizes.height/this.height);

              // We resize the image with the canvas method drawImage();
              context.drawImage(this, 0, 0);

              var dataURI = canvas.toDataURL('image/jpeg');

              //update the pictureData array
              self.splice('pictureData', wantedImageIndex,1,dataURI);

          };
          // We put the Data URI in the image's src attribute
          img.src = imageData;
      },
      //calculate the appropriate width and height based on the image and the longEdgePixels, shortEdgePixels and maxMegaPixels
      _calculateRescaledPictureSize: function(image) {
        var ret = {
          width: image.width,
          height: image.height,
        }

        //case 1: both longEdgePixels and shortEdgePixels are given. This alaway wins, regardless of picture size
        if (this.shortEdgePixels && this.longEdgePixels) {
          if (image.width > image.height) {
            ret.width = this.longEdgePixels;
            ret.height = this.shortEdgePixels;
          }
          else {
            ret.height = this.longEdgePixels;
            ret.width = this.shortEdgePixels;
          }
          return ret;
        }

        //case 2a: longEdgePixels is given but not shortEdgePixels. rescale picture and keep dimensions
        if (this.longEdgePixels) {
          if (image.width > image.height) {
            ret.width = this.longEdgePixels;
            ret.height = Math.round((this.longEdgePixels/image.width)*image.height);
          }
          else {
            ret.height = this.longEdgePixels;
            ret.width = Math.round((this.longEdgePixels/image.height)*image.width);
          }
          return ret;
        }
        //case 2a: shortEdgePixels is given but not longEdgePixels. rescale picture and keep dimensions
        if (this.shortEdgePixels) {
          if (image.width > image.height) {
            ret.height = this.shortEdgePixels;
            ret.width = Math.round((this.shortEdgePixels/image.height)*image.width);
          }
          else {
            ret.width = this.shortEdgePixels;
            ret.height = Math.round((this.shortEdgePixels/image.width)*image.height);
          }
          return ret;
        }

        //case 3: neither longEdgePixels nor shortEdgePixels are given. rescale picture to remain below maxMegaPixels
        var mMP = this.maxMegaPixels * 1000000;
        if ((image.width * image.height) <= mMP) {
          return ret; //do not rescale
        }
        var factor = Math.sqrt(mMP / (image.width * image.height));

        ret.height = Math.floor(factor * image.height);
        ret.width = Math.floor(factor * image.width);

        return ret;
      },
    });
  </script>
</dom-module>
